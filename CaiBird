202-HappyNumber-java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer>set=new HashSet<>();
        while(n!=1)
        {
            if(!set.add(n))
            {
                return false;
            }
            int value=0;
            while(n!=0)
            {
                value+=(n%10)*(n%10);
                n/=10;
            }
            n=value;
        }
        return true;
    }
}
303-简单动态规划问题-java
class NumArray {
    
    private int[]dp;

    public NumArray(int[] nums) {
        if(nums.length==0)
            return;
        dp=new int[nums.length];
        dp[0]=nums[0];
        for(int i=1;i<dp.length;i++)
        {
            dp[i]=nums[i]+dp[i-1];
        }
        
    }
    
    public int sumRange(int i, int j) {
        return i==0?dp[j]:dp[j]-dp[i-1];
        
    }
}
141-环形链表-java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head==null||head.next==null)
            return false;
        ListNode slow = head;
        ListNode fast = head.next;
        while(slow!=fast){
            if(fast==null||fast.next==null)
                return false;
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
234-回文链表-java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head==null||head.next==null)
            return true;
        ListNode fast = head;
        ListNode slow = head;
        while(fast.next!=null&&fast.next.next!=null)
        {
            fast=fast.next.next;
            slow=slow.next;
        }
        slow = reverse(slow.next);
        while(slow!=null)
        {
            if(head.val!=slow.val)
                return false;
            head=head.next;
            slow=slow.next;
        }
        return true;
        
    }
    private ListNode reverse(ListNode head)
    {
        if(head.next==null)
            return head;
        ListNode newHead = reverse(head.next);
        head.next.next=head;
        head.next=null;
        return newHead;
    }
}
231-2的幂次-java
class Solution {
    public boolean isPowerOfTwo(int n) {
        
        if(n<=0)
            return false; 
        if((n&n-1)==0) 
            return true; 
        else
            return false;
    }
}    //3是011，4是100；2是10，1是01.
344-反转字符串-java
class Solution {
    public void reverseString(char[] s) {
        for(int i=0;i<s.length/2;i++)
        {
            char temp=s[i];
            s[i]=s[s.length-1-i];
            s[s.length-1-i]=temp;
        }
        
    }
}
7-整数反转-java
class Solution {
    public int reverse(int x) {
        int rev = 0;
        while(x!=0){
            int pop = x % 10;
             x /= 10;
            if(rev > Integer.MAX_VALUE/10||(rev==Integer.MAX_VALUE/10&&pop>7))
                return 0;
            if(rev < Integer.MIN_VALUE/10||(rev==Integer.MIN_VALUE/10&&pop<-8))
                return 0;
                                                     //2^31-1=2147483647,-2^31=-2147483648
            rev = rev * 10 + pop;
        }
        return rev;
        
    }
}
268-缺失数字-java
class Solution {
    public int missingNumber(int[] nums) {
        int res = nums.length;
        for (int i = 0; i < nums.length; ++i){
            res ^= nums[i];
            res ^= i;
        }
        return res;

    }
}   //比较取巧方法，一般用映射做
628-三个数的最大乘积-java
class Solution {
    public int maximumProduct(int[] nums) {
       int len=nums.length;
       Arrays.sort(nums);
       if(nums.length<3){
           return 0;
       }
        return Math.max(nums[len-1]*nums[len-2]*nums[len-3],nums[0]*nums[1]*nums[len-1]);

    }
}
448-找到消失的数字-java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        for(int i=0;i<nums.length;i++)
            nums[Math.abs(nums[i])-1]=-Math.abs(nums[Math.abs(nums[i])-1]); //把每个nums[i]对应的数组下标的值变为负值
        List <Integer> list=new ArrayList <Integer>();
        for(int i=0;i<nums.length;i++)
        {
            if(nums[i]>0)
                list.add(i+1);
        }
        return list;
    }
}
198-打家劫舍-java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n <= 1) return n == 0 ? 0 : nums[0];
        int[] memo = new int[n];
        memo[0] = nums[0];
        memo[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++)
            memo[i] = Math.max(memo[i - 1], nums[i] + memo[i - 2]);
        return memo[n - 1];
            
    }
}
