202-HappyNumber-java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer>set=new HashSet<>();
        while(n!=1)
        {
            if(!set.add(n))
            {
                return false;
            }
            int value=0;
            while(n!=0)
            {
                value+=(n%10)*(n%10);
                n/=10;
            }
            n=value;
        }
        return true;
    }
}
303-简单动态规划问题-java
class NumArray {
    
    private int[]dp;

    public NumArray(int[] nums) {
        if(nums.length==0)
            return;
        dp=new int[nums.length];
        dp[0]=nums[0];
        for(int i=1;i<dp.length;i++)
        {
            dp[i]=nums[i]+dp[i-1];
        }
        
    }
    
    public int sumRange(int i, int j) {
        return i==0?dp[j]:dp[j]-dp[i-1];
        
    }
}
141-环形链表-java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head==null||head.next==null)
            return false;
        ListNode slow = head;
        ListNode fast = head.next;
        while(slow!=fast){
            if(fast==null||fast.next==null)
                return false;
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
234-回文链表-java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head==null||head.next==null)
            return true;
        ListNode fast = head;
        ListNode slow = head;
        while(fast.next!=null&&fast.next.next!=null)
        {
            fast=fast.next.next;
            slow=slow.next;
        }
        slow = reverse(slow.next);
        while(slow!=null)
        {
            if(head.val!=slow.val)
                return false;
            head=head.next;
            slow=slow.next;
        }
        return true;
        
    }
    private ListNode reverse(ListNode head)
    {
        if(head.next==null)
            return head;
        ListNode newHead = reverse(head.next);
        head.next.next=head;
        head.next=null;
        return newHead;
    }
}
231-2的幂次-java
class Solution {
    public boolean isPowerOfTwo(int n) {
        
        if(n<=0)
            return false; 
        if((n&n-1)==0) 
            return true; 
        else
            return false;
    }
}    //3是011，4是100；2是10，1是01.
344-反转字符串-java
class Solution {
    public void reverseString(char[] s) {
        for(int i=0;i<s.length/2;i++)
        {
            char temp=s[i];
            s[i]=s[s.length-1-i];
            s[s.length-1-i]=temp;
        }
        
    }
}
7-整数反转-java
class Solution {
    public int reverse(int x) {
        int rev = 0;
        while(x!=0){
            int pop = x % 10;
             x /= 10;
            if(rev > Integer.MAX_VALUE/10||(rev==Integer.MAX_VALUE/10&&pop>7))
                return 0;
            if(rev < Integer.MIN_VALUE/10||(rev==Integer.MIN_VALUE/10&&pop<-8))
                return 0;
                                                     //2^31-1=2147483647,-2^31=-2147483648
            rev = rev * 10 + pop;
        }
        return rev;
        
    }
}
268-缺失数字-java
class Solution {
    public int missingNumber(int[] nums) {
        int res = nums.length;
        for (int i = 0; i < nums.length; ++i){
            res ^= nums[i];
            res ^= i;
        }
        return res;

    }
}   //比较取巧方法，一般用映射做
628-三个数的最大乘积-java
class Solution {
    public int maximumProduct(int[] nums) {
       int len=nums.length;
       Arrays.sort(nums);
       if(nums.length<3){
           return 0;
       }
        return Math.max(nums[len-1]*nums[len-2]*nums[len-3],nums[0]*nums[1]*nums[len-1]);

    }
}
448-找到消失的数字-java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        for(int i=0;i<nums.length;i++)
            nums[Math.abs(nums[i])-1]=-Math.abs(nums[Math.abs(nums[i])-1]); //把每个nums[i]对应的数组下标的值变为负值
        List <Integer> list=new ArrayList <Integer>();
        for(int i=0;i<nums.length;i++)
        {
            if(nums[i]>0)
                list.add(i+1);
        }
        return list;
    }
}
198-打家劫舍-java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n <= 1) return n == 0 ? 0 : nums[0];
        int[] memo = new int[n];
        memo[0] = nums[0];
        memo[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++)
            memo[i] = Math.max(memo[i - 1], nums[i] + memo[i - 2]);
        return memo[n - 1];
            
    }
}
2-两数之和-java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2){
    ListNode dummyHead = new ListNode(0);
    ListNode p = l1, q = l2, curr = dummyHead;
    int carry = 0;
    while (p != null || q != null) {
        int x = (p != null) ? p.val : 0;
        int y = (q != null) ? q.val : 0;
        int sum = carry + x + y;
        carry = sum / 10;
        curr.next = new ListNode(sum % 10);
        curr = curr.next;
        if (p != null) p = p.next;
        if (q != null) q = q.next;
    }
    if (carry > 0) {
        curr.next = new ListNode(carry);
    }
    return dummyHead.next;
    }
}
283-移动0-java
class Solution {
    public void moveZeroes(int[] nums) {
        int i = 0,j = 0;
        for(i = 0; i < nums.length; i++)
        {
            if(nums[i] != 0)
            {
                nums[j++] = nums[i];
            }
        }
        while(j < nums.length)
        {
            nums[j++] = 0;
        }
    }
}
136-只出现一次的数字-java
class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for(int i = 0; i < nums.length; i++)
        {
            result ^=nums[i];
        }
        return result;
    }
}
1037-回旋镖-java
class Solution {
    public boolean isBoomerang(int[][] points) {
       return (points[0][0] * (points[1][1] - points[2][1]) + points[1][0] * (points[2][1] - points[0][1]) + points[2][0] * (points[0][1] - points[1][1])) != 0;
        //三角形行列式求面积公式
    }
}
349-两个数组的交集-java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {

        Set<Integer> set1 = new HashSet<Integer>();
        for (int num : nums1) {
            set1.add(num);
        }
        int idx = 0;
        for (int i = 0; i < nums2.length; i++) {
            if (set1.contains(nums2[i])) {
                nums2[idx++] = nums2[i];
                set1.remove(nums2[i]);
            }
        }
        return Arrays.copyOfRange(nums2, 0, idx);
            
    }
}
83-删除排序链表中的重复元素-java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode last = head;
        ListNode next = null;
        if(last != null)
        {
            next = last.next;
        }
        while(next != null)
        {
            if(next.val == last.val)
                last.next = next.next;
            else
                last = next;
            next = last.next;
        }
        return head;       
    }
}
21-合并两个有序链表-java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode cur = dummyHead;
        while(l1 != null && l2 != null)
        {
            if(l1.val < l2.val)
            {
                cur.next = l1;
                l1 = l1.next;
                cur = cur.next;
            }
            else
            {
                cur.next = l2;
                cur = cur.next;
                l2 = l2.next;
            }
        }
        if(l1 == null)
            cur.next = l2;
        if(l2 == null)
            cur.next = l1;
         return dummyHead.next;
    }
}
455-分发蛋糕-java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        int child = 0;
        int cookie = 0;
        Arrays.sort(g);
        Arrays.sort(s);
        while(child < g.length && cookie <s.length)
        {
            if(g[child] <= s[cookie])
                child++;
            cookie++;
        }
        return child;    
    }
}
441-排列硬币-java
class Solution {
    public int arrangeCoins(int n) {
        int i = 0;
        while(i <= n)
        {
            n = n - i;
            if(n < 0)
                break;
            i++;
        }
        return i - 1;
    }
}
561-数组拆分I-java
class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort (nums);
        int ans = 0;
        for(int i = 0; i < nums.length / 2; i++)
        {
            ans += nums[i*2];
        }
        return ans;        
    }
}
746-使用最小花费爬楼梯-java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[]dp = new int[n];
        dp[0] = cost[0];
        dp[1] = cost[1];
        for(int i = 2; i<n; i++)
        {
            dp[i]=Math.min(dp[i-1],dp[i-2]) + cost[i];
        }
        return Math.min(dp[n-1],dp[n-2]);
    }
}
1025-除数博弈-java
class Solution {
    public boolean divisorGame(int N) {
        if(N % 2 == 0)
            return true;
        else
            return false;
    }
}
278-第一个版本错误的数字-java
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int l = 1;
        int r = n;
        while (l < r) {
            int mid = l + (r - l) / 2;   //mid = (l + r) / 2; 容易溢出
            if (isBadVersion(mid)) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return r;
    }
}
191-位1的个数
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        for(int i = 0; i < 32; i++)
        {
            if(((n>>i)&1) == 1)
                count ++;
        }
        return count;
    }
}
726-二进制表示中质数个计算置位-java
class Solution {
    public int countPrimeSetBits(int L, int R) {
        int resCount = 0;
        for (int num = L; num <= R; ++num){
            int tempNum = num, tempCount = 0;
            while (tempNum != 0){
                tempNum &= (tempNum - 1);
                tempCount += 1;
            }
            if (isPrime(tempCount)){
                resCount += 1;
            }
        }
        return resCount;
    }

   private boolean isPrime(int num){
        if (num < 2){
            return false;
        }
        for (int i = (int)(Math.sqrt(num)); i > 1; --i){
            if (num % i == 0){
                return false;
            }
        }
        return true;
    }
}
137-只出现一次的数字-java
class Solution {
    public int singleNumber(int[] nums) {
        int a = 0, b = 0;
        for(int x = 0; x < nums.length; x++)
        {
            b = (b ^ nums[x]) & ~a;
            a = (a ^ nums[x]) & ~b;
        }
        return b;
    }
}
237-删除链表中的节点-java
class Solution {
    public void deleteNode(ListNode node) {
        node.val=node.next.val;
        node.next=node.next.next;
    }
}
203-移除链表元素-java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
       if(head == null)
           return null;
        ListNode p = head;
        ListNode q = p.next;
        
        while(q != null)
        {
            if(q.val==val)
            {
                p.next=q.next;
                q=q.next;
            }
            else
            {
                p=q;
                q=p.next;
            }
        }
        if(head.val==val)
        {
            return head.next;
        }
        
        return head;
    }
}
160-相交链表-java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA == null || headB == null)
            return null;
        ListNode pA = headA, pB = headB;
        while(pA != pB)
        {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
}
876-链表的中间节点-java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast.next != null && fast.next.next != null)
        {
            fast = fast.next.next;
            slow = slow.next;
        }
        return fast.next == null ? slow : slow.next;
        
    }
}
19-删除链表的第k个节点-java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
         if( head == null){
            return null;
        }
        ListNode temp = new ListNode(0);
        temp.next = head;
        ListNode l = temp;
        ListNode r = head;
        head = temp;
        for(int i = 0; i < n; i++){
            r = r.next;
        }
        while(r != null){
            r = r.next;
            l = l.next;
        }
        l.next = l.next.next;
        return head.next;
    }
}
922-按奇偶排序数组2-java
class Solution {
    public int[] sortArrayByParityII(int[] A) {
        int i = 0;
        int j = 1;
        while (j < A.length && i < A.length) {
            if (A[i] % 2 == 0) {
                i += 2;
            } else {
                while (A[j] % 2 != 0 && j < A.length) {
                    j += 2;
                }
                if (j < A.length) {
                    int temp = A[i];
                    A[i] = A[j];
                    A[j] = temp;
                }
            }
        }
        return A;    
    }
}
350-两个数组的交集2-java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        List<Integer> list = new ArrayList<>();
        for(int i = 0, j = 0; i < nums1.length && j < nums2.length;)
        {
            if(nums1[i] < nums2[j])
                i++;
            else if(nums1[i] > nums2[j])
                j++;
            else{
                list.add(nums1[i]);
                i++;
                j++;
            }
        }
        int [] res = new int[list.size()];
        for(int i = 0; i < list.size(); i++)
        {
            res[i] = list.get(i);
        }
        return res;
    }
}
976-三角形的最大周长-java
class Solution {
    public int largestPerimeter(int[] A) {
        Arrays.sort(A);
        for(int i = A.length - 1; i >= 2; i--)
        {
            int a = A[i];
            int b = A[i-1];
            int c = A[i-2];
            if(a < b + c)
            {
                return a + b + c;
            }
        }
        return 0;
    }
}
33-搜索旋转排序数组-java
class Solution {
    public int search(int[] nums, int target) {
        return search(nums, 0, nums.length - 1, target);
    }
    
    private int search(int[] nums, int low, int high, int target) {
        if (low > high)
            return -1;
        int mid = (low + high) / 2;
        if (nums[mid] == target)
            return mid;
        if (nums[mid] < nums[high]) {
            if (nums[mid] < target && target <= nums[high])
                return search(nums, mid + 1, high, target); //中间数小于目标数且目标数小于等于最右边数，则在中间数右边找
            else
                return search(nums, low, mid - 1, target); //中间数大于目标数或者目标数大于最右边数，则在中间数左边找
        } else {
            if (nums[low] <= target && target < nums[mid])
                return search(nums, low, mid - 1, target);
            else
                return search(nums, mid + 1, high, target);
        }
    }
}
48-旋转图像-java
class Solution {
    public void rotate(int[][] matrix) {
        int abs1 = 0;
        int abs2 = matrix.length - 1;
        while (abs1 <= abs2) {
            int p1 = abs1;
            int p2 = abs2;
            while (p1 != abs2) {
                int temp = matrix[abs1][p1];        
                matrix[abs1][p1] = matrix[p2][abs1];
                matrix[p2][abs1] = matrix[abs2][p2];
                matrix[abs2][p2] = matrix[p1][abs2];
                matrix[p1][abs2] = temp;               //最外面先换，再换里面
                p1 += 1;
                p2 -= 1;
            }
            abs1 += 1;
            abs2 -= 1;
        }
}
}
566-重塑矩阵-java
class Solution {
    public int[][] matrixReshape(int[][] nums, int r, int c) {
        int row = nums.length, col = nums[0].length;
        if (row * col != r * c) 
            return nums;
        int [][] res = new int[r][c];
        int index = 0;
        for (int i = 0; i < r; i++){
            for (int j = 0; j < c; j++){
                res[i][j] = nums[index / col][index % col];
                index ++;
            }
        }
        return res;
    }
}
1033-移动石子直到连续-java
class Solution {
    public int[] numMovesStones(int a, int b, int c) {
        int max, min;
        min = Math.min(a, Math.min(b, c));
        max = Math.max(a, Math.max(b, c));
        b = a + b + c - max - min;
        a= min;
        c = max;
        
        if (Math.abs(b - a) == 1 && Math.abs(c - b) == 1)
        {
            return new int[]{0, 0};
        }
        else if (Math.abs(b - a) <= 2 || Math.abs(c - b) <= 2) 
        {
            return new int[]{1, c - a-2};
        }
        else
        {
            return new int[]{2, c - a-2};
        }

    }
}
    
